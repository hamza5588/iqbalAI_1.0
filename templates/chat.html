<!DOCTYPE html>
<html lang="en">
<head>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            myblue: '#05B0FC',
          },
          fontFamily: {
            inter: ['Inter', 'sans-serif'],
          },
        }
      }
    }
  </script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Google Fonts & Font Awesome -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

  <!-- Markdown Library -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/lib/highlight.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/styles/github.min.css">

  <title>AI Chat Interface</title>
</head>
<body class="h-screen bg-gray-100 font-inter">

  <div class="flex h-full">

    <!-- Sidebar -->
    <div id="sidebar" class="w-[275px] bg-white shadow-md p-4">
      <div class="flex justify-between items-center">
        <img src="{{ url_for('static', filename='images/logo.png') }}" height="80" width="140" alt="Logo">
        <button onclick="hideSidebar()" class="mt-4 hover:bg-gray-100 p-1 rounded">
          <img src="{{ url_for('static', filename='images/slider.png') }}" alt="Toggle" class="w-6 h-6">
        </button>
      </div>
      
      <!-- Border Line -->
      <div class="mt-4 border-t-2 border-gray-300 -mx-4"></div>
      
      <!-- Token Usage Meter -->
      <!--
      <div class="mt-6 mb-2 w-full">
        <div class="flex items-center justify-between mb-1">
          <span class="text-xs text-gray-500">Tokens Used</span>
          <span class="text-xs text-gray-500"><span id="tokenUsed">0</span> / <span id="tokenLimit">0</span></span>
        </div>
        <div class="w-full h-3 bg-gray-200 rounded-full">
          <div id="tokenProgressBar" class="h-full bg-gradient-to-r from-green-400 to-blue-500 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
      </div>
      -->
      
      <div class="flex flex-col space-y-4 justify-center items-center mt-6 mb-2">

        <!-- New Chat -->
        <button onclick="startNewChat()" class="w-[200px] h-[50px] mt-3 mb-2 px-4 flex items-center justify-center gap-2 bg-[#05B0FC] text-white font-bold rounded transition duration-200 ease-in-out hover:bg-blue-600">
          <img src="{{ url_for('static', filename='images/msg.png') }}" alt="Message" class="w-5 h-5">
          <span>New Chat</span>
        </button>

        <!-- Action Buttons -->
        <button onclick="openLessonGenerator()" class="w-[230px] h-[40px] px-4 flex items-center gap-3 font-semibold text-[16px] text-gray-700 hover:bg-gray-50 rounded transition-colors">
          <img src="{{ url_for('static', filename='images/lesson.png') }}" alt="Lesson" class="w-5 h-5">
          <span>Generate Lessons</span>
        </button>

        <button onclick="updateApiKey()" class="w-[230px] h-[40px] px-4 flex items-center gap-3 font-semibold text-[16px] text-gray-700 hover:bg-gray-50 rounded transition-colors">
         <img src="{{ url_for('static', filename='images/key.png') }}" alt="Key" class="w-5 h-5">
          <span>Update API Key</span>
        </button>

        <button onclick="startRealTimeChat()" id="realTimeChatBtn" class="w-[230px] h-[40px] px-4 flex items-center gap-3 font-semibold text-[16px] text-gray-700 hover:bg-gray-50 rounded transition-colors">
         <img src="{{ url_for('static', filename='images/timer.png') }}" alt="Timer" class="w-5 h-5">
          <span>Real Time Chat</span>
        </button>

        <button onclick="resetChat()" class="w-[230px] h-[40px] px-4 flex items-center gap-3 font-semibold text-[16px] text-gray-700 hover:bg-gray-50 rounded transition-colors">
          <i class="fas fa-refresh text-[#B7B7B7] w-5 h-5"></i>
          <span>Reset Chat</span>
        </button>

        <!-- Chat History Button -->
        <button onclick="toggleDropdown()" class="w-[260px] h-[40px] px-4 flex items-center justify-between font-semibold text-[16px] text-gray-700 mt-2 hover:bg-gray-50 rounded transition-colors">
          <i class="fas fa-history text-[#B7B7B7]"></i>
          <span>Chat History</span>
          <i class="fas fa-chevron-down text-[#666]" id="historyArrow"></i>
        </button>

        <!-- Dropdown Chat History -->
        <div id="dropdownContent" class="mt-2 hidden flex-col gap-3 w-[240px] max-h-48 overflow-y-auto">
          <!-- Chat history items will be populated here -->
        </div>

        

        <!-- Logout Button -->
        <button onclick="logout()" class="fixed bottom-4 w-[230px] h-[40px] px-4 flex items-center justify-center gap-3 font-semibold text-[16px] text-gray-700 bg-white shadow rounded hover:bg-gray-50 transition-colors">
          <i class="fas fa-sign-out-alt text-[#F50D0D]"></i>
          <span class="text-[#F50D0D]">Log out</span>
        </button>

      </div>
    </div>

    <!-- Main Content -->
    <div class="flex-1 bg-white min-h-screen flex flex-col">
        
        <!-- Search Section -->
        <div class="px-6 py-4">
            <div class="relative flex gap-3">
                <div class="relative flex-1">
                    <i class="fas fa-search absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-400 text-sm"></i>
                    <input
                        type="text"
                        placeholder="Search Conversations and Knowledge base..."
                        class="w-full pl-12 pr-4 py-3 border-0 rounded-xl bg-gray-100 focus:outline-none text-gray-600 placeholder-gray-500"
                        onkeypress="handleSearchKeyPress(event)"
                    />
                </div>
                <button class="w-12 h-12 rounded-xl bg-gray-100 flex items-center justify-center hover:bg-gray-200 transition-colors">
                    <i class="fas fa-bell text-gray-500"></i>
                </button>
            </div>
        </div>

        <!-- Tabs Section -->
        <div class="flex items-center justify-between px-6 py-4">
            <div class="bg-gray-100 rounded-2xl p-1 flex">
                <button
                    onclick="changeTab(this)"
                    class="tab-btn px-8 py-3 text-blue-500 font-semibold bg-white rounded-xl shadow-sm"
                >
                    Chat
                </button>
                <div class="relative">
                    <button
                        class="tab-btn px-8 py-3 text-gray-400 font-semibold cursor-not-allowed opacity-50"
                        disabled
                    >
                        Knowledge Base
                    </button>
                    <div class="absolute -top-2 -right-2 bg-yellow-500 text-white text-xs px-2 py-1 rounded-full font-medium shadow-sm">
                        Coming Soon
                    </div>
                </div>
            </div>
            <div class="w-11 h-11 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold text-sm">
                AI
            </div>
        </div>

        <!-- Chat Header Section -->
        <div class="flex items-center justify-between px-6 py-4 border-t border-gray-100">
            <div class="flex items-center gap-3">
                <div class="w-11 h-11 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold text-sm">
                    AI
                </div>
                <div>
                    <h3 class="text-gray-900 font-semibold text-lg" id="chatTitle">New Chat</h3>
                    <p class="text-gray-500 text-sm" id="chatStatus">Online</p>
                </div>
            </div>
            
            <div class="flex items-center gap-2">
                <button onclick="downloadCurrentChat()" class="w-10 h-10 border border-gray-200 rounded-lg flex items-center justify-center hover:bg-gray-50 transition-colors">
                    <i class="fas fa-download text-gray-500 text-sm"></i>
                </button>
                <button class="w-10 h-10 border border-gray-200 rounded-lg flex items-center justify-center hover:bg-gray-50 transition-colors">
                    <i class="fas fa-ellipsis-h text-gray-500 text-sm"></i>
                </button>
            </div>
        </div>

        <!-- Chat Messages Area -->
        <div class="flex-1 px-6 py-8 overflow-y-auto" id="chatMessages">
            <div class="flex items-start gap-4">
                <div class="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold text-sm flex-shrink-0">
                    AI
                </div>
                <div class="bg-gray-100 rounded-2xl px-5 py-4 max-w-lg markdown-content">
                    Hello! I'm your **AI assistant**. How can I help you today?

You can:
- Ask me questions
- Get help with coding
- Generate lessons from files
- Use voice input/output
- Switch between languages (Hindi, Urdu, English)
                </div>
            </div>
        </div>
        
        <!-- Voice Recording Indicator -->
        <div id="voiceRecordingIndicator" class="hidden px-6 py-2 bg-red-50 border-l-4 border-red-500">
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 bg-red-500 rounded-full animate-pulse"></div>
                <span class="text-red-700 font-medium">Recording... Click to stop</span>
                <button onclick="stopRecording()" class="ml-auto text-red-700 hover:text-red-900">
                    <i class="fas fa-stop-circle text-xl"></i>
                </button>
            </div>
        </div>

        <!-- Input Area -->
        <div class="px-6 py-4 border-t border-gray-100">
            <div class="flex items-center gap-3">
                <button onclick="toggleVoiceRecording()" id="micButton" class="w-12 h-12 border border-gray-200 rounded-xl flex items-center justify-center hover:bg-gray-50 transition-all duration-300">
                  <img src="{{ url_for('static', filename='images/recorder.png') }}" alt="" id="micIcon">
                </button>
                <button onclick="toggleVoiceOutput()" id="voiceOutputBtn" class="w-12 h-12 border border-gray-200 rounded-xl flex items-center justify-center hover:bg-gray-50 transition-all duration-300">
                      <img src="{{ url_for('static', filename='images/voice.png') }}" alt="" id="speakerIcon">
                </button>
                
                <div class="flex-1 relative">
                    <input
                        type="text"
                        id="messageInput"
                        placeholder="Type your message"
                        class="w-full px-6 py-4 bg-gray-100 rounded-full border-0 focus:outline-none text-gray-700 placeholder-gray-500"
                        onkeypress="handleKeyPress(event)"
                    />
                    <button class="absolute right-4 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600">
                        <i class="far fa-smile text-xl"></i>
                    </button>
                </div>
                
                <button onclick="sendMessage()" class="w-12 h-12 bg-blue-500 rounded-xl flex items-center justify-center hover:bg-blue-600 transition-colors">
                    <img src="{{ url_for('static', filename='images/sender.png') }}" alt="">
                </button>
            </div>
        </div>
    </div>

  </div>

  <!-- File Upload Modal for Lesson Generator -->
  <div id="fileUploadModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
    <div class="bg-white rounded-xl p-6 w-96 max-w-full mx-4">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold text-gray-900">Upload File for Lesson Generation</h3>
        <button onclick="closeFileUploadModal()" class="text-gray-500 hover:text-gray-700">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center">
        <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4"></i>
        <p class="text-gray-600 mb-4">Drag and drop your file here, or click to browse</p>
        <input type="file" id="lessonFileInput" class="hidden" accept=".pdf,.doc,.docx,.txt,.ppt,.pptx" onchange="handleFileSelect(event)">
        <button onclick="document.getElementById('lessonFileInput').click()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600">
          Choose File
        </button>
      </div>
      
      <div id="selectedFileName" class="hidden mt-4 p-3 bg-gray-100 rounded-lg">
        <div class="flex items-center justify-between">
          <span class="text-sm text-gray-700"></span>
          <button onclick="removeSelectedFile()" class="text-red-500 hover:text-red-700">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>
      
      <div class="flex gap-3 mt-6">
        <button onclick="closeFileUploadModal()" class="flex-1 px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">
          Cancel
        </button>
        <button onclick="generateLesson()" id="generateLessonBtn" class="flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50" disabled>
          Generate Lesson
        </button>
      </div>
    </div>
  </div>

  <!-- API Key Update Modal -->
  <div id="apiKeyModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
    <div class="bg-white rounded-xl p-6 w-96 max-w-full mx-4">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold text-gray-900">Update API Key</h3>
        <button onclick="closeApiKeyModal()" class="text-gray-500 hover:text-gray-700">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-2">GROQ API Key</label>
        <div class="relative">
          <input type="password" id="apiKeyInput" placeholder="Enter your GROQ API key..." class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400">
          <button onclick="toggleApiKeyVisibility()" class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700">
            <i class="fas fa-eye" id="toggleApiKeyIcon"></i>
          </button>
        </div>
        <p class="text-xs text-gray-500 mt-1">Get your API key from <a href="https://console.groq.com/keys" target="_blank" class="text-blue-500 hover:underline">Groq Console</a></p>
      </div>
      
      <div class="flex gap-3">
        <button onclick="closeApiKeyModal()" class="flex-1 px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">
          Cancel
        </button>
        <button onclick="saveApiKey()" class="flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600">
          Save
        </button>
      </div>
    </div>
  </div>

  <!-- Survey Modal -->
  <div id="surveyModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
    <div class="bg-white rounded-xl p-6 w-96 max-w-full mx-4">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold text-gray-900">How was your experience?</h3>
        <button onclick="closeSurvey()" class="text-gray-500 hover:text-gray-700">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <div class="mb-4">
        <p class="text-gray-600 mb-4">Please rate your experience with our AI chat:</p>
        <div class="flex justify-center gap-2 mb-4">
          <div class="rating-buttons flex gap-1">
            <!-- Rating buttons 1-10 -->
            <button onclick="selectRating(1)" class="rating-btn w-8 h-8 border-2 border-gray-300 rounded-full text-sm hover:border-blue-500" data-rating="1">1</button>
            <button onclick="selectRating(2)" class="rating-btn w-8 h-8 border-2 border-gray-300 rounded-full text-sm hover:border-blue-500" data-rating="2">2</button>
            <button onclick="selectRating(3)" class="rating-btn w-8 h-8 border-2 border-gray-300 rounded-full text-sm hover:border-blue-500" data-rating="3">3</button>
            <button onclick="selectRating(4)" class="rating-btn w-8 h-8 border-2 border-gray-300 rounded-full text-sm hover:border-blue-500" data-rating="4">4</button>
            <button onclick="selectRating(5)" class="rating-btn w-8 h-8 border-2 border-gray-300 rounded-full text-sm hover:border-blue-500" data-rating="5">5</button>
            <button onclick="selectRating(6)" class="rating-btn w-8 h-8 border-2 border-gray-300 rounded-full text-sm hover:border-blue-500" data-rating="6">6</button>
            <button onclick="selectRating(7)" class="rating-btn w-8 h-8 border-2 border-gray-300 rounded-full text-sm hover:border-blue-500" data-rating="7">7</button>
            <button onclick="selectRating(8)" class="rating-btn w-8 h-8 border-2 border-gray-300 rounded-full text-sm hover:border-blue-500" data-rating="8">8</button>
            <button onclick="selectRating(9)" class="rating-btn w-8 h-8 border-2 border-gray-300 rounded-full text-sm hover:border-blue-500" data-rating="9">9</button>
            <button onclick="selectRating(10)" class="rating-btn w-8 h-8 border-2 border-gray-300 rounded-full text-sm hover:border-blue-500" data-rating="10">10</button>
          </div>
        </div>
        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700 mb-2">Additional Comments</label>
          <textarea id="surveyMessage" rows="3" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="Tell us about your experience..."></textarea>
        </div>
      </div>
      
      <div class="flex gap-3">
        <button onclick="closeSurvey()" class="flex-1 px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50">
          Cancel
        </button>
        <button onclick="submitSurvey()" id="submitSurveyBtn" class="flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50" disabled>
          Submit
        </button>
      </div>
    </div>
  </div>

  <!-- Real-time Voice Chat Modal -->
  <div id="voiceChatModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
    <div class="bg-white rounded-xl p-6 w-80 max-w-full mx-4">
      <div class="text-center">
        <div class="w-20 h-20 bg-gradient-to-br from-green-400 to-blue-500 rounded-full mx-auto mb-4 flex items-center justify-center animate-pulse">
          <i class="fas fa-microphone text-white text-2xl"></i>
        </div>
        <h3 class="text-lg font-semibold text-gray-900 mb-2">Real-time Voice Chat</h3>
        <p class="text-gray-600 mb-4" id="voiceChatStatus">Connecting...</p>
        <div id="voiceChatTimer" class="text-2xl font-mono text-gray-800 mb-4">00:00</div>
        <button onclick="endVoiceChat()" class="px-6 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600">
          End Call
        </button>
      </div>
    </div>
  </div>

  <!-- JS -->
  <script>
    // Global variables
    let chatHistory = [];
    let currentChatId = null;
    let isRecording = false;
    let isVoiceOutputEnabled = false;
    let mediaRecorder = null;
    let audioChunks = [];
    let recognition = null;
    let synthesis = null;
    let selectedRating = null;
    let voiceChatConnection = null;
    let voiceChatTimer = null;
    let voiceChatSeconds = 0;
    let hybridMode = false; // Hybrid mode: English voice recognition + Urdu/Hindi text

    // Markdown Configuration
    marked.setOptions({
      highlight: function(code, lang) {
        if (lang && hljs.getLanguage(lang)) {
          try {
            return hljs.highlight(code, { language: lang }).value;
          } catch (err) {}
        }
        return hljs.highlightAuto(code).value;
      },
      breaks: true,
      gfm: true
    });

    // Initialize
    window.onload = function() {
      loadChatHistory();
      startNewChat();
      updateTokenMeter();
      checkApiKeyStatus();
      
      // Check if user should see survey
      setTimeout(() => {
        checkSurveyStatus();
      }, 5000); // Check after 5 seconds
    };

    // API Integration Functions

    // Create new conversation
    async function startNewChat() {
      try {
        const response = await fetch('/create_conversation', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ title: 'New Chat' })
        });
        
        if (response.ok) {
          const data = await response.json();
          currentChatId = data.conversation_id;
        } else {
          currentChatId = Date.now(); // Fallback to timestamp
        }
      } catch (error) {
        console.error('Error creating conversation:', error);
        currentChatId = Date.now(); // Fallback to timestamp
      }

      document.getElementById('chatTitle').textContent = 'New Chat';
      document.getElementById('chatStatus').textContent = 'Online';
      
      // Clear chat messages
      const chatMessages = document.getElementById('chatMessages');
      const welcomeMessage = `Hello! I'm your **AI assistant**. How can I help you today?

You can:
- Ask me questions
- Get help with coding
- Generate lessons from files
- Use voice input/output`;

      chatMessages.innerHTML = `
        <div class="flex items-start gap-4">
          <div class="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold text-sm flex-shrink-0">
            AI
          </div>
          <div class="bg-gray-100 rounded-2xl px-5 py-4 max-w-lg markdown-content">
            ${renderMarkdown(welcomeMessage)}
          </div>
        </div>
      `;
      
      // Clear input
      document.getElementById('messageInput').value = '';
      
      // Reload conversations
      loadChatHistory();
    }

    // Send message to backend
    async function sendMessage() {
      const input = document.getElementById('messageInput');
      const message = input.value.trim();
      
      if (message) {
        addMessageToChat('user', message);
        input.value = '';
        
        // Show typing indicator
        showTypingIndicator();
        
        try {
          const response = await fetch('/chat', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              input: message,
              conversation_id: currentChatId
            })
          });

          hideTypingIndicator();
          
          if (response.ok) {
            const data = await response.json();
            if (data.error) {
              addMessageToChat('ai', `Error: ${data.error}`);
            } else {
              addMessageToChat('ai', data.response);
              
              // Only speak if voice output is enabled
              if (isVoiceOutputEnabled) {
                speakText(data.response);
              }
            }
          } else {
            const errorData = await response.json();
            addMessageToChat('ai', `Error: ${errorData.error || 'Failed to get response'}`);
          }
          
          // Update token meter after response
          updateTokenMeter();
          
        } catch (error) {
          hideTypingIndicator();
          console.error('Error sending message:', error);
          addMessageToChat('ai', 'Sorry, there was an error processing your message. Please try again.');
        }
        
        // Save chat
        saveChatToHistory();
      }
    }

    // Load conversations from backend
    async function loadChatHistory() {
      try {
        const response = await fetch('/get_conversations');
        if (response.ok) {
          const conversations = await response.json();
          chatHistory = conversations.map(conv => ({
            id: conv.id,
            title: conv.title || 'New Chat',
            timestamp: conv.created_at || new Date().toISOString(),
            messageCount: conv.message_count || 0
          }));
        } else {
          // Fallback to local storage or empty array
          chatHistory = JSON.parse(localStorage.getItem('chatHistory') || '[]');
        }
      } catch (error) {
        console.error('Error loading chat history:', error);
        chatHistory = JSON.parse(localStorage.getItem('chatHistory') || '[]');
      }
      
      updateChatHistoryDisplay();
    }

    // Load messages for a specific conversation
    async function loadChat(chatId) {
      try {
        const response = await fetch(`/get_messages/${chatId}`);
        if (response.ok) {
          const messages = await response.json();
          
          currentChatId = chatId;
          const chat = chatHistory.find(c => c.id === chatId);
          if (chat) {
            document.getElementById('chatTitle').textContent = chat.title;
          }
          
          // Clear and reload messages
          const chatMessages = document.getElementById('chatMessages');
          chatMessages.innerHTML = '';
          
          messages.forEach(message => {
            addMessageToChat(message.role === 'user' ? 'user' : 'ai', message.message);
          });
          
        } else {
          console.error('Failed to load messages');
        }
      } catch (error) {
        console.error('Error loading chat:', error);
      }
    }

    // Delete all conversations (reset chat)
    async function resetChat() {
      if (confirm('Are you sure you want to reset all chats? This will delete all conversations.')) {
        try {
          const response = await fetch('/delete_all_conversations', {
            method: 'DELETE'
          });
          
          if (response.ok) {
            chatHistory = [];
            updateChatHistoryDisplay();
            startNewChat();
            showNotification('All conversations have been deleted', 'success');
          } else {
            showNotification('Failed to delete conversations', 'error');
          }
        } catch (error) {
          console.error('Error resetting chat:', error);
          showNotification('Error deleting conversations', 'error');
        }
      }
    }

    // Download current chat
    async function downloadCurrentChat() {
      if (!currentChatId) {
        showNotification('No active conversation to download', 'error');
        return;
      }

      try {
        const response = await fetch(`/download_chat/${currentChatId}`);
        
        if (response.ok) {
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `chat_conversation_${currentChatId}.docx`;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          a.remove();
          showNotification('Chat downloaded successfully', 'success');
        } else {
          showNotification('Failed to download chat', 'error');
        }
      } catch (error) {
        console.error('Error downloading chat:', error);
        showNotification('Error downloading chat', 'error');
      }
    }

    // Update API Key
    async function saveApiKey() {
      const apiKeyInput = document.getElementById('apiKeyInput');
      const newApiKey = apiKeyInput.value.trim();

      if (!newApiKey) {
        showNotification('Please enter an API key', 'error');
        return;
      }

      try {
        const response = await fetch('/update_api_key', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ api_key: newApiKey })
        });

        if (response.ok) {
          const data = await response.json();
          if (data.success) {
            showNotification('API key updated successfully', 'success');
            closeApiKeyModal();
            apiKeyInput.value = '';
          } else {
            showNotification(data.error || 'Failed to update API key', 'error');
          }
        } else {
          const errorData = await response.json();
          showNotification(errorData.error || 'Failed to update API key', 'error');
        }
      } catch (error) {
        console.error('Error updating API key:', error);
        showNotification('Error updating API key', 'error');
      }
    }

    // Check API Key Status
    async function checkApiKeyStatus() {
      try {
        const response = await fetch('/check_api_key_status');
        if (response.ok) {
          const data = await response.json();
          if (!data.has_api_key || data.is_expired) {
            // Show API key modal with blinking effect
            setTimeout(() => {
              updateApiKey();
              const modal = document.getElementById('apiKeyModal');
              modal.classList.add('animate-pulse');
            }, 2000);
          }
        }
      } catch (error) {
        console.error('Error checking API key status:', error);
      }
    }

    // Generate Lesson from File
    async function generateLesson() {
      const fileInput = document.getElementById('lessonFileInput');
      const file = fileInput.files[0];
      
      if (!file) {
        showNotification('Please select a file', 'error');
        return;
      }

      const formData = new FormData();
      formData.append('file', file);

      closeFileUploadModal();
      addMessageToChat('user', `Generate a lesson from: ${file.name}`);
      showTypingIndicator();

      try {
        const response = await fetch('/generate_lesson', {
          method: 'POST',
          body: formData
        });

        hideTypingIndicator();

        if (response.ok) {
          // Check if response is a file download
          const contentType = response.headers.get('content-type');
          if (contentType && contentType.includes('application/vnd.openxmlformats-officedocument.wordprocessingml.document')) {
            // Handle file download
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lesson_${file.name.split('.')[0]}.docx`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();
            
            addMessageToChat('ai', `I've successfully generated a lesson from "${file.name}" and downloaded it as a Word document. The lesson includes structured content, learning objectives, and assessment questions based on your uploaded material.`);
          } else {
            // Handle JSON response
            const data = await response.json();
            if (data.error) {
              addMessageToChat('ai', `Error generating lesson: ${data.error}`);
            } else {
              addMessageToChat('ai', data.message || 'Lesson generated successfully');
            }
          }
        } else {
          const errorData = await response.json();
          addMessageToChat('ai', `Error generating lesson: ${errorData.error || 'Failed to generate lesson'}`);
        }
      } catch (error) {
        hideTypingIndicator();
        console.error('Error generating lesson:', error);
        addMessageToChat('ai', 'Sorry, there was an error generating the lesson. Please try again.');
      }

      saveChatToHistory();
    }

    // Update Token Meter
    async function updateTokenMeter() {
      try {
        const response = await fetch('/token_status');
        if (response.ok) {
          const data = await response.json();
          
          if (!data.error) {
            const percentUsed = Math.min(100, (data.used / data.limit) * 100);
            
            // Update progress bar (with null check)
            const progressBar = document.getElementById('tokenProgressBar');
            if (progressBar) {
              progressBar.style.width = `${percentUsed}%`;
              
              // Update colors based on usage
              if (percentUsed > 90) {
                progressBar.className = 'h-full bg-gradient-to-r from-red-400 to-red-600 rounded-full transition-all duration-300';
              } else if (percentUsed > 75) {
                progressBar.className = 'h-full bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full transition-all duration-300';
              } else {
                progressBar.className = 'h-full bg-gradient-to-r from-green-400 to-blue-500 rounded-full transition-all duration-300';
              }
            }
            
            // Update numbers (with null checks)
            const tokenUsed = document.getElementById('tokenUsed');
            const tokenLimit = document.getElementById('tokenLimit');
            if (tokenUsed) tokenUsed.textContent = data.used.toLocaleString();
            if (tokenLimit) tokenLimit.textContent = data.limit.toLocaleString();
          }
        }
      } catch (error) {
        console.error('Error updating token meter:', error);
      }
    }

    // Survey Functions
    async function checkSurveyStatus() {
      try {
        const response = await fetch('/api/check_survey_status');
        if (response.ok) {
          const data = await response.json();
          if (!data.has_submitted) {
            // Show survey after 5 minutes if not submitted
            setTimeout(() => {
              showSurvey();
            }, 300000); // 5 minutes
          }
        }
      } catch (error) {
        console.error('Error checking survey status:', error);
      }
    }

    function showSurvey() {
      document.getElementById('surveyModal').classList.remove('hidden');
    }

    function closeSurvey() {
      document.getElementById('surveyModal').classList.add('hidden');
      selectedRating = null;
      document.getElementById('surveyMessage').value = '';
      document.getElementById('submitSurveyBtn').disabled = true;
      
      // Reset rating buttons
      document.querySelectorAll('.rating-btn').forEach(btn => {
        btn.classList.remove('bg-blue-500', 'text-white');
        btn.classList.add('border-gray-300');
      });
    }

    function selectRating(rating) {
      selectedRating = rating;
      
      // Update button styles
      document.querySelectorAll('.rating-btn').forEach(btn => {
        btn.classList.remove('bg-blue-500', 'text-white');
        btn.classList.add('border-gray-300');
      });
      
      const selectedBtn = document.querySelector(`[data-rating="${rating}"]`);
      selectedBtn.classList.add('bg-blue-500', 'text-white');
      selectedBtn.classList.remove('border-gray-300');
      
      // Enable submit button
      document.getElementById('submitSurveyBtn').disabled = false;
    }

    async function submitSurvey() {
      if (!selectedRating) {
        showNotification('Please select a rating', 'error');
        return;
      }

      const message = document.getElementById('surveyMessage').value.trim();

      try {
        const response = await fetch('/api/survey', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            rating: selectedRating,
            message: message
          })
        });

        if (response.ok) {
          const data = await response.json();
          if (data.success) {
            showNotification('Thank you for your feedback!', 'success');
            closeSurvey();
          } else {
            showNotification(data.error || 'Failed to submit survey', 'error');
          }
        } else {
          const errorData = await response.json();
          showNotification(errorData.error || 'Failed to submit survey', 'error');
        }
      } catch (error) {
        console.error('Error submitting survey:', error);
        showNotification('Error submitting survey', 'error');
      }
    }

    // Real-time Voice Chat
    async function startRealTimeChat() {
      const btn = document.getElementById('realTimeChatBtn');
      
      if (voiceChatConnection) {
        endVoiceChat();
        return;
      }

      try {
        // Get session token first
        const sessionResponse = await fetch('/session');
        if (!sessionResponse.ok) {
          throw new Error('Failed to get session token');
        }

        const sessionData = await sessionResponse.json();
        const ephemeralKey = sessionData.client_secret.value;

        // Request microphone permission
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Show voice chat modal
        document.getElementById('voiceChatModal').classList.remove('hidden');
        document.getElementById('voiceChatStatus').textContent = 'Connecting...';
        
        // Create RTCPeerConnection
        const peerConnection = new RTCPeerConnection({
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });

        // Add local audio track
        stream.getTracks().forEach(track => {
          peerConnection.addTrack(track, stream);
        });

        // Setup audio output
        const audioElement = document.createElement('audio');
        audioElement.autoplay = true;
        peerConnection.ontrack = event => {
          audioElement.srcObject = event.streams[0];
        };

        // Create offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        // Send offer to OpenAI
        const response = await fetch('https://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-12-17', {
          method: 'POST',
          body: offer.sdp,
          headers: {
            'Authorization': `Bearer ${ephemeralKey}`,
            'Content-Type': 'application/sdp'
          }
        });

        if (!response.ok) {
          throw new Error('Failed to establish voice connection');
        }

        const answer = {
          type: 'answer',
          sdp: await response.text()
        };
        await peerConnection.setRemoteDescription(answer);

        voiceChatConnection = peerConnection;
        document.getElementById('voiceChatStatus').textContent = 'Connected';
        
        // Start timer
        startVoiceChatTimer();
        
        btn.innerHTML = `
          <div class="w-3 h-3 bg-red-500 rounded-full animate-pulse"></div>
          <span>End Voice Chat</span>
        `;
        btn.classList.add('bg-red-50', 'text-red-700');

      } catch (error) {
        console.error('Voice chat error:', error);
        showNotification('Failed to start voice chat: ' + error.message, 'error');
        endVoiceChat();
      }
    }

    function startVoiceChatTimer() {
      voiceChatSeconds = 0;
      voiceChatTimer = setInterval(() => {
        voiceChatSeconds++;
        const minutes = Math.floor(voiceChatSeconds / 60);
        const seconds = voiceChatSeconds % 60;
        document.getElementById('voiceChatTimer').textContent = 
          `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }, 1000);
    }

    function endVoiceChat() {
      if (voiceChatConnection) {
        voiceChatConnection.close();
        voiceChatConnection = null;
      }
      
      if (voiceChatTimer) {
        clearInterval(voiceChatTimer);
        voiceChatTimer = null;
      }
      
      document.getElementById('voiceChatModal').classList.add('hidden');
      
      const btn = document.getElementById('realTimeChatBtn');
      btn.innerHTML = `
        <img src="{{ url_for('static', filename='images/timer.png') }}" alt="Timer" class="w-5 h-5">
        <span>Real Time Chat</span>
      `;
      btn.classList.remove('bg-red-50', 'text-red-700');
      
      showNotification('Voice chat ended', 'info');
    }

    // Voice Input/Output Functions
    function toggleVoiceRecording() {
      if (!isRecording) {
        startVoiceInput();
      } else {
        stopVoiceInput();
      }
    }

    function startVoiceInput() {
      if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        
        // Use English for voice recognition
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.start();
        isRecording = true;
        
        document.getElementById('voiceRecordingIndicator').classList.remove('hidden');
        const micBtn = document.getElementById('micButton');
        const micIcon = document.getElementById('micIcon');
        
        // Enhanced visual feedback for recording state
        micBtn.classList.add('bg-red-500', 'border-red-500', 'shadow-lg', 'animate-pulse');
        micBtn.classList.remove('hover:bg-gray-50');
        micIcon.style.filter = 'brightness(0) invert(1)'; // Make icon white
        
        // Add recording indicator dot
        if (!document.getElementById('recordingDot')) {
          const recordingDot = document.createElement('div');
          recordingDot.id = 'recordingDot';
          recordingDot.className = 'absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full animate-pulse';
          micBtn.style.position = 'relative';
          micBtn.appendChild(recordingDot);
        }

        recognition.onresult = (event) => {
          const transcript = event.results[0][0].transcript;
          document.getElementById('messageInput').value = transcript;
          stopVoiceInput();
          
          // Automatically enable voice output when user uses voice input
          if (!isVoiceOutputEnabled) {
            isVoiceOutputEnabled = true;
            const btn = document.getElementById('voiceOutputBtn');
            btn.classList.add('bg-green-500', 'border-green-500');
            btn.classList.remove('hover:bg-gray-50');
            const speakerIcon = document.getElementById('speakerIcon');
            speakerIcon.style.filter = 'brightness(0) invert(1)'; // Make icon white
            showNotification('Voice output enabled for voice interaction', 'info');
          }
          
          sendMessage();
        };

                recognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);
          
          // Handle specific error types
          if (event.error === 'network') {
            showNotification('Network error: Please check your internet connection and try again', 'error');
          } else if (event.error === 'not-allowed') {
            showNotification('Microphone access denied. Please allow microphone access and try again', 'error');
          } else if (event.error === 'no-speech') {
            showNotification('No speech detected. Please try speaking again', 'warning');
          } else if (event.error === 'audio-capture') {
            showNotification('Audio capture error. Please check your microphone', 'error');
          } else if (event.error === 'service-not-allowed') {
            showNotification('Speech recognition service not available', 'error');
          } else {
            showNotification('Voice recognition error: ' + event.error, 'error');
          }
          
          stopVoiceInput();
        };

        recognition.onend = () => {
          stopVoiceInput();
        };
      } else {
        showNotification('Speech recognition not supported in this browser', 'error');
      }
    }

    function stopVoiceInput() {
      if (recognition) {
        recognition.stop();
      }
      isRecording = false;
      document.getElementById('voiceRecordingIndicator').classList.add('hidden');
      
      const micBtn = document.getElementById('micButton');
      const micIcon = document.getElementById('micIcon');
      
      // Reset visual feedback
      micBtn.classList.remove('bg-red-500', 'border-red-500', 'shadow-lg', 'animate-pulse');
      micBtn.classList.add('hover:bg-gray-50');
      micIcon.style.filter = 'brightness(0) invert(0)'; // Reset icon color
      
      // Remove recording dot
      const recordingDot = document.getElementById('recordingDot');
      if (recordingDot) {
        recordingDot.remove();
      }
    }

    function toggleVoiceOutput() {
      const btn = document.getElementById('voiceOutputBtn');
      
      // Toggle voice output state
      isVoiceOutputEnabled = !isVoiceOutputEnabled;
      
      if (isVoiceOutputEnabled) {
        // Enable voice output
        btn.classList.add('bg-green-500', 'border-green-500');
        btn.classList.remove('hover:bg-gray-50');
        const speakerIcon = document.getElementById('speakerIcon');
        speakerIcon.style.filter = 'brightness(0) invert(1)'; // Make icon white
        showNotification('Voice output enabled - AI responses will be spoken', 'success');
      } else {
        // Disable voice output and stop any current speech
        if (window.speechSynthesis && window.speechSynthesis.speaking) {
          window.speechSynthesis.cancel();
        }
        btn.classList.remove('bg-green-500', 'border-green-500', 'bg-red-500', 'border-red-500', 'animate-pulse');
        btn.classList.add('hover:bg-gray-50');
        const speakerIcon = document.getElementById('speakerIcon');
        speakerIcon.style.filter = 'brightness(0) invert(0)'; // Reset icon color
        showNotification('Voice output disabled', 'info');
      }
    }

    function speakText(text) {
      if ('speechSynthesis' in window) {
        // Cancel any ongoing speech
        window.speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.0;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        // Use English voice
        const voices = window.speechSynthesis.getVoices();
        let selectedVoice = voices.find(voice => 
          voice.name.includes('Female') || 
          voice.name.includes('Zira') || 
          voice.name.includes('Emma') ||
          voice.name.includes('Google UK English Female') ||
          voice.name.includes('Google US English Female')
        );
        
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        // Set language for the utterance
        utterance.lang = 'en-US';
        
        // Add visual feedback when speech starts
        const btn = document.getElementById('voiceOutputBtn');
        const speakerIcon = document.getElementById('speakerIcon');
        
        // Show speaking state (red pulsing)
        btn.classList.add('bg-red-500', 'border-red-500', 'animate-pulse');
        btn.classList.remove('bg-green-500', 'border-green-500', 'hover:bg-gray-50');
        speakerIcon.style.filter = 'brightness(0) invert(1)'; // Make icon white
        
        // Add event listeners for speech start and end
        utterance.onstart = () => {
          console.log('Speech started');
        };
        
        utterance.onend = () => {
          // Reset to enabled state (green) when speech ends
          btn.classList.remove('bg-red-500', 'border-red-500', 'animate-pulse');
          if (isVoiceOutputEnabled) {
            btn.classList.add('bg-green-500', 'border-green-500');
          } else {
            btn.classList.add('hover:bg-gray-50');
            speakerIcon.style.filter = 'brightness(0) invert(0)'; // Reset icon color
          }
        };
        
        utterance.onerror = () => {
          // Reset to enabled state (green) on error
          btn.classList.remove('bg-red-500', 'border-red-500', 'animate-pulse');
          if (isVoiceOutputEnabled) {
            btn.classList.add('bg-green-500', 'border-green-500');
          } else {
            btn.classList.add('hover:bg-gray-50');
            speakerIcon.style.filter = 'brightness(0) invert(0)'; // Reset icon color
          }
        };
        
        window.speechSynthesis.speak(utterance);
      }
    }

    // Logout function
    async function logout() {
      try {
        const response = await fetch('/auth/logout', {
          method: 'POST',
          credentials: 'include'
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.success && data.redirect_url) {
            window.location.href = data.redirect_url;
          } else {
            window.location.href = '/login';
          }
        } else {
          // Fallback
          window.location.href = '/logout';
        }
      } catch (error) {
        console.error('Logout error:', error);
        window.location.href = '/logout';
      }
    }

    // Utility Functions
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `fixed top-4 right-4 z-50 px-4 py-2 rounded-lg text-white font-medium transform transition-all duration-300 translate-x-full`;
      
      switch(type) {
        case 'success':
          notification.classList.add('bg-green-500');
          break;
        case 'error':
          notification.classList.add('bg-red-500');
          break;
        case 'warning':
          notification.classList.add('bg-yellow-500');
          break;
        default:
          notification.classList.add('bg-blue-500');
      }
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Animate in
      setTimeout(() => {
        notification.classList.remove('translate-x-full');
      }, 100);
      
      // Remove after 3 seconds
      setTimeout(() => {
        notification.classList.add('translate-x-full');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    function showTypingIndicator() {
      const chatMessages = document.getElementById('chatMessages');
      const typingDiv = document.createElement('div');
      typingDiv.id = 'typingIndicator';
      typingDiv.className = 'flex items-start gap-4 mb-4';
      typingDiv.innerHTML = `
        <div class="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold text-sm flex-shrink-0">
          AI
        </div>
        <div class="bg-gray-100 rounded-2xl px-5 py-4 max-w-lg">
          <div class="flex space-x-1">
            <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
            <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
            <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
          </div>
        </div>
      `;
      chatMessages.appendChild(typingDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function hideTypingIndicator() {
      const typingIndicator = document.getElementById('typingIndicator');
      if (typingIndicator) {
        typingIndicator.remove();
      }
    }

    // Existing UI Functions (continued from original code)
    function hideSidebar() {
      const sidebar = document.getElementById('sidebar');
      const mainContent = document.querySelector('.flex-1');
      
      sidebar.innerHTML = `
        <div class="flex flex-col h-full justify-between items-center py-4">
          <button onclick="showSidebar()" class="w-10 h-10 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded-lg flex items-center justify-center transition-colors">
            <i class="fas fa-bars"></i>
          </button>
          <button onclick="logout()" class="w-10 h-10 bg-white shadow hover:bg-gray-50 text-red-600 rounded-lg flex items-center justify-center transition-colors">
            <i class="fas fa-sign-out-alt"></i>
          </button>
        </div>
      `;
      sidebar.className = "w-16 bg-white shadow-md";
      mainContent.style.marginLeft = "8px";
    }

    function showSidebar() {
      location.reload(); // Simplified approach to restore sidebar
    }

    function addMessageToChat(sender, message) {
      const chatMessages = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'flex items-start gap-4 mb-4';
      
      if (sender === 'user') {
        messageDiv.innerHTML = `
          <div class="flex items-start gap-4 flex-row-reverse w-full">
            <div class="w-10 h-10 bg-gray-500 rounded-full flex items-center justify-center text-white font-bold text-sm flex-shrink-0">
              U
            </div>
            <div class="bg-blue-500 text-white rounded-2xl px-5 py-4 max-w-lg">
              <p class="leading-relaxed">${escapeHtml(message)}</p>
            </div>
          </div>
        `;
      } else {
        // Render markdown for AI responses
        const renderedMessage = renderMarkdown(message);
        messageDiv.innerHTML = `
          <div class="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold text-sm flex-shrink-0">
            AI
          </div>
          <div class="bg-gray-100 rounded-2xl px-5 py-4 max-w-lg markdown-content">
            ${renderedMessage}
          </div>
        `;
        
        // Apply syntax highlighting to code blocks
        setTimeout(() => {
          const codeBlocks = messageDiv.querySelectorAll('pre code');
          codeBlocks.forEach(block => {
            hljs.highlightElement(block);
          });
        }, 10);
      }
      
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function handleKeyPress(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    }

    function handleSearchKeyPress(event) {
      if (event.key === 'Enter') {
        const searchTerm = event.target.value.trim();
        if (searchTerm) {
          addMessageToChat('user', `Search: ${searchTerm}`);
          setTimeout(() => {
            addMessageToChat('ai', `I found several results related to "${searchTerm}". Here are the most relevant items from our knowledge base and conversation history.`);
            saveChatToHistory();
          }, 1000);
        }
      }
    }

    function saveChatToHistory() {
      // This would typically save to backend, but for now we'll use localStorage as fallback
      localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
    }

    function generateChatTitle() {
      const chatMessages = document.getElementById('chatMessages');
      const userMessages = Array.from(chatMessages.children).filter((msg, index) => index > 0 && msg.innerHTML.includes('bg-blue-500 text-white'));
      
      if (userMessages.length > 0) {
        const firstUserMessage = userMessages[0].textContent.trim();
        return firstUserMessage.length > 30 ? firstUserMessage.substring(0, 30) + '...' : firstUserMessage;
      }
      
      return 'New Chat';
    }

    function updateChatHistoryDisplay() {
      const dropdown = document.getElementById('dropdownContent');
      dropdown.innerHTML = '';
      
      chatHistory.forEach(chat => {
        const chatItem = document.createElement('div');
        chatItem.className = 'flex items-center justify-between px-3 py-2 hover:bg-gray-100 rounded cursor-pointer';
        chatItem.innerHTML = `
          <div class="text-sm text-gray-700 flex-1" onclick="loadChat(${chat.id})">
            <span class="block font-medium">${chat.title}</span>
            <span class="text-xs text-gray-500">${formatTimestamp(chat.timestamp)}</span>
          </div>
          <div class="flex items-center space-x-3 text-gray-500">
            <i onclick="downloadChat(${chat.id})" class="fas fa-download hover:text-black cursor-pointer"></i>
            <i onclick="deleteChat(${chat.id})" class="fas fa-trash hover:text-red-600 cursor-pointer"></i>
          </div>
        `;
        dropdown.appendChild(chatItem);
      });
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));
      
      if (diffDays === 0) return 'Today';
      if (diffDays === 1) return 'Yesterday';
      return `${diffDays} days ago`;
    }

    async function downloadChat(chatId) {
      try {
        const response = await fetch(`/download_chat/${chatId}`);
        if (response.ok) {
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `chat_${chatId}.docx`;
          a.click();
          URL.revokeObjectURL(url);
          showNotification('Chat downloaded successfully', 'success');
        } else {
          showNotification('Failed to download chat', 'error');
        }
      } catch (error) {
        console.error('Error downloading chat:', error);
        showNotification('Error downloading chat', 'error');
      }
    }

    async function deleteChat(chatId) {
      if (confirm('Are you sure you want to delete this chat?')) {
        // Here you would call a delete API endpoint
        chatHistory = chatHistory.filter(chat => chat.id !== chatId);
        updateChatHistoryDisplay();
        saveChatToHistory();
        showNotification('Chat deleted successfully', 'success');
      }
    }

    function toggleDropdown() {
      const dropdown = document.getElementById('dropdownContent');
      const arrow = document.getElementById('historyArrow');
      
      if (dropdown.classList.contains('hidden')) {
        dropdown.classList.remove('hidden');
        arrow.classList.add('fa-chevron-up');
        arrow.classList.remove('fa-chevron-down');
      } else {
        dropdown.classList.add('hidden');
        arrow.classList.remove('fa-chevron-up');
        arrow.classList.add('fa-chevron-down');
      }
    }

    // Modal Functions
    function openLessonGenerator() {
      document.getElementById('fileUploadModal').classList.remove('hidden');
    }

    function closeFileUploadModal() {
      document.getElementById('fileUploadModal').classList.add('hidden');
      document.getElementById('selectedFileName').classList.add('hidden');
      document.getElementById('lessonFileInput').value = '';
      document.getElementById('generateLessonBtn').disabled = true;
    }

    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (file) {
        const fileNameDisplay = document.getElementById('selectedFileName');
        fileNameDisplay.querySelector('span').textContent = file.name;
        fileNameDisplay.classList.remove('hidden');
        document.getElementById('generateLessonBtn').disabled = false;
      }
    }

    function removeSelectedFile() {
      document.getElementById('selectedFileName').classList.add('hidden');
      document.getElementById('lessonFileInput').value = '';
      document.getElementById('generateLessonBtn').disabled = true;
    }

    function updateApiKey() {
      document.getElementById('apiKeyModal').classList.remove('hidden');
    }

    function closeApiKeyModal() {
      document.getElementById('apiKeyModal').classList.add('hidden');
      document.getElementById('apiKeyInput').value = '';
    }

    function toggleApiKeyVisibility() {
      const input = document.getElementById('apiKeyInput');
      const icon = document.getElementById('toggleApiKeyIcon');
      
      if (input.type === 'password') {
        input.type = 'text';
        icon.classList.remove('fa-eye');
        icon.classList.add('fa-eye-slash');
      } else {
        input.type = 'password';
        icon.classList.remove('fa-eye-slash');
        icon.classList.add('fa-eye');
      }
    }

    function changeTab(button) {
      console.log('changeTab function called with:', button.textContent.trim());
      const tabButtons = document.querySelectorAll('.tab-btn');
      tabButtons.forEach(btn => {
        btn.classList.remove('text-blue-500', 'bg-white', 'shadow-sm');
        btn.classList.add('text-gray-500');
      });
      
      button.classList.remove('text-gray-500');
      button.classList.add('text-blue-500', 'bg-white', 'shadow-sm');
      
      // Only handle Chat tab since Knowledge Base is disabled
      if (currentChatId) {
        loadChat(currentChatId);
      } else {
        startNewChat();
      }
    }

    // Drag and drop functionality
    function initializeDragAndDrop() {
      const modal = document.getElementById('fileUploadModal');
      const dropZone = modal.querySelector('.border-dashed');
      
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, preventDefaults, false);
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      ['dragenter', 'dragover'].forEach(eventName => {
        dropZone.addEventListener(eventName, highlight, false);
      });

      ['dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, unhighlight, false);
      });

      function highlight(e) {
        dropZone.classList.add('border-blue-500', 'bg-blue-50');
      }

      function unhighlight(e) {
        dropZone.classList.remove('border-blue-500', 'bg-blue-50');
      }

      dropZone.addEventListener('drop', handleDrop, false);

      function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        
        if (files.length > 0) {
          const fileInput = document.getElementById('lessonFileInput');
          fileInput.files = files;
          handleFileSelect({ target: fileInput });
        }
      }
    }

    // Enhanced voice recording with real audio processing
    async function startVoiceRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };
        
        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
          
          // Here you could send the audio to a speech-to-text service
          // For now, we'll use the browser's speech recognition
          showNotification('Voice message recorded', 'success');
          
          // Clean up
          stream.getTracks().forEach(track => track.stop());
        };
        
        mediaRecorder.start();
        isRecording = true;
        
        document.getElementById('voiceRecordingIndicator').classList.remove('hidden');
        
      } catch (error) {
        console.error('Error accessing microphone:', error);
        showNotification('Error accessing microphone: ' + error.message, 'error');
      }
    }

    function stopRecording() {
      if (isRecording && mediaRecorder) {
        mediaRecorder.stop();
        isRecording = false;
        document.getElementById('voiceRecordingIndicator').classList.add('hidden');
      }
    }

    // Auto-save and periodic updates
    setInterval(() => {
      if (currentChatId) {
        updateTokenMeter();
      }
    }, 30000); // Update token meter every 30 seconds

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Ctrl/Cmd + N for new chat
      if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
        e.preventDefault();
        startNewChat();
      }
      
      // Ctrl/Cmd + R for reset chat
      if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        e.preventDefault();
        resetChat();
      }
      
      // Escape to close modals
      if (e.key === 'Escape') {
        closeFileUploadModal();
        closeApiKeyModal();
        closeSurvey();
        if (voiceChatConnection) {
          endVoiceChat();
        }
      }

      // Ctrl/Cmd + Enter to send message
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        e.preventDefault();
        sendMessage();
      }
    });

    // Enhanced error handling for all API calls
    function handleApiError(error, context = 'API call') {
      console.error(`${context} error:`, error);
      
      if (error.message.includes('Failed to fetch')) {
        showNotification('Connection error. Please check your internet connection.', 'error');
      } else if (error.message.includes('401')) {
        showNotification('Authentication error. Please check your API key.', 'error');
        updateApiKey();
      } else if (error.message.includes('429')) {
        showNotification('Rate limit exceeded. Please wait before trying again.', 'warning');
      } else if (error.message.includes('500')) {
        showNotification('Server error. Please try again later.', 'error');
      } else {
        showNotification(`${context} failed: ${error.message}`, 'error');
      }
    }

    // Enhanced message formatting with markdown support
    function formatMessage(message) {
      // Basic markdown formatting
      return message
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/```(.*?)```/gs, '<pre><code>$1</code></pre>')
        .replace(/`(.*?)`/g, '<code>$1</code>')
        .replace(/\n/g, '<br>');
    }

    // Load voices for text-to-speech
    function loadVoices() {
      return new Promise((resolve) => {
        let voices = window.speechSynthesis.getVoices();
        if (voices.length) {
          resolve(voices);
        } else {
          window.speechSynthesis.addEventListener('voiceschanged', () => {
            voices = window.speechSynthesis.getVoices();
            resolve(voices);
          });
        }
      });
    }

    // Enhanced file validation
    function validateFile(file) {
      const allowedTypes = [
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'text/plain',
        'application/vnd.ms-powerpoint',
        'application/vnd.openxmlformats-officedocument.presentationml.presentation'
      ];
      
      const maxSize = 10 * 1024 * 1024; // 10MB
      
      if (!allowedTypes.includes(file.type)) {
        throw new Error('File type not supported. Please upload PDF, DOC, DOCX, TXT, PPT, or PPTX files.');
      }
      
      if (file.size > maxSize) {
        throw new Error('File size too large. Please upload files smaller than 10MB.');
      }
      
      return true;
    }

    // Enhanced search functionality
    async function searchConversations(query) {
      try {
        // In a real implementation, this would search through conversation content
        const filteredChats = chatHistory.filter(chat => 
          chat.title.toLowerCase().includes(query.toLowerCase())
        );
        
        if (filteredChats.length === 0) {
          addMessageToChat('ai', `No conversations found matching "${query}". Try different keywords.`);
        } else {
          addMessageToChat('ai', `Found ${filteredChats.length} conversation(s) matching "${query}"`);
        }
        
        updateChatHistoryDisplay();
        saveChatToHistory();
        
      } catch (error) {
        handleApiError(error, 'Search');
      }
    }

    // Mobile responsiveness improvements
    function handleMobileLayout() {
      const isMobile = window.innerWidth <= 768;
      
      if (isMobile) {
        // Adjust UI for mobile
        const sidebar = document.getElementById('sidebar');
        sidebar.classList.add('mobile-sidebar');
        
        // Add mobile menu toggle
        if (!document.getElementById('mobileMenuToggle')) {
          const toggleBtn = document.createElement('button');
          toggleBtn.id = 'mobileMenuToggle';
          toggleBtn.className = 'fixed top-4 left-4 z-50 w-10 h-10 bg-white shadow-lg rounded-lg flex items-center justify-center lg:hidden';
          toggleBtn.innerHTML = '<i class="fas fa-bars text-gray-600"></i>';
          toggleBtn.onclick = () => {
            sidebar.classList.toggle('mobile-sidebar-open');
          };
          document.body.appendChild(toggleBtn);
        }
      }
    }

    // Initialize mobile layout on resize
    window.addEventListener('resize', handleMobileLayout);

    // Auto-retry mechanism for failed requests
    async function retryApiCall(apiCall, maxRetries = 3, delay = 1000) {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          return await apiCall();
        } catch (error) {
          if (attempt === maxRetries) {
            throw error;
          }
          
          console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2; // Exponential backoff
        }
      }
    }

    // Session management
    function checkSession() {
      fetch('/check_session')
        .then(response => {
          if (!response.ok) {
            throw new Error('Session expired');
          }
          return response.json();
        })
        .then(data => {
          if (!data.valid) {
            showNotification('Session expired. Please log in again.', 'warning');
            setTimeout(() => {
              window.location.href = '/login';
            }, 2000);
          }
        })
        .catch(error => {
          console.error('Session check failed:', error);
        });
    }

    // Check session every 5 minutes
    setInterval(checkSession, 5 * 60 * 1000);

    // Initialize everything when page loads
    document.addEventListener('DOMContentLoaded', function() {
      initializeDragAndDrop();
      handleMobileLayout();
      
      // Load voices for text-to-speech
      loadVoices().then(voices => {
        console.log('Available voices loaded:', voices.length);
      });
      
      // Set up periodic token updates
      setInterval(updateTokenMeter, 60000); // Update every minute
      
      // Initial session check
      checkSession();
    });

    // Service worker registration for offline support (optional)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(registration => {
            console.log('SW registered: ', registration);
          })
          .catch(registrationError => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }

    // Export functions for potential module use
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = {
        sendMessage,
        startNewChat,
        loadChatHistory,
        updateTokenMeter,
        generateLesson,
        startRealTimeChat,
        saveApiKey
      };
    }

    // Markdown rendering and HTML escaping helpers
    function renderMarkdown(text) {
      try {
        // Convert markdown to HTML
        const html = marked.parse(text);
        return html;
      } catch (error) {
        console.error('Markdown rendering error:', error);
        return escapeHtml(text);
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

  </script>

  <style>
    /* Additional CSS for enhanced functionality */
    .mobile-sidebar {
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      position: fixed;
      z-index: 40;
      height: 100vh;
    }
    
    .mobile-sidebar-open {
      transform: translateX(0);
    }
    
    @media (max-width: 768px) {
      .flex-1 {
        margin-left: 0 !important;
      }
    }
    
    .animate-bounce {
      animation: bounce 1s infinite;
    }
    
    @keyframes bounce {
      0%, 20%, 53%, 80%, 100% {
        transform: translate3d(0,0,0);
      }
      40%, 43% {
        transform: translate3d(0,-15px,0);
      }
      70% {
        transform: translate3d(0,-7px,0);
      }
      90% {
        transform: translate3d(0,-2px,0);
      }
    }
    
    .rating-btn.selected {
      background: #3b82f6 !important;
      color: white !important;
      border-color: #3b82f6 !important;
    }
    
    /* Custom scrollbar */
    .overflow-y-auto::-webkit-scrollbar {
      width: 6px;
    }
    
    .overflow-y-auto::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    .overflow-y-auto::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
    }
    
    .overflow-y-auto::-webkit-scrollbar-thumb:hover {
      background: #a1a1a1;
    }
    
    /* Focus styles for accessibility */
    button:focus,
    input:focus,
    textarea:focus {
      outline: 2px solid #3b82f6;
      outline-offset: 2px;
    }
    
    /* Loading animation */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Markdown Content Styles */
    .markdown-content {
      line-height: 1.6;
      color: #374151;
    }
    
    .markdown-content h1,
    .markdown-content h2,
    .markdown-content h3,
    .markdown-content h4,
    .markdown-content h5,
    .markdown-content h6 {
      margin-top: 1.5em;
      margin-bottom: 0.5em;
      font-weight: 600;
      line-height: 1.25;
    }
    
    .markdown-content h1 {
      font-size: 1.5em;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3em;
    }
    
    .markdown-content h2 {
      font-size: 1.3em;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3em;
    }
    
    .markdown-content h3 {
      font-size: 1.1em;
    }
    
    .markdown-content p {
      margin-bottom: 1em;
    }
    
    .markdown-content ul,
    .markdown-content ol {
      margin-bottom: 1em;
      padding-left: 1.5em;
    }
    
    .markdown-content li {
      margin-bottom: 0.25em;
    }
    
    .markdown-content blockquote {
      border-left: 4px solid #3b82f6;
      padding-left: 1em;
      margin: 1em 0;
      color: #6b7280;
      font-style: italic;
    }
    
    .markdown-content code {
      background-color: #f3f4f6;
      padding: 0.2em 0.4em;
      border-radius: 0.25em;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #dc2626;
    }
    
    .markdown-content pre {
      background-color: #1f2937;
      color: #f9fafb;
      padding: 1em;
      border-radius: 0.5em;
      overflow-x: auto;
      margin: 1em 0;
    }
    
    .markdown-content pre code {
      background-color: transparent;
      padding: 0;
      color: inherit;
      font-size: 0.9em;
    }
    
    .markdown-content table {
      border-collapse: collapse;
      width: 100%;
      margin: 1em 0;
    }
    
    .markdown-content th,
    .markdown-content td {
      border: 1px solid #d1d5db;
      padding: 0.5em;
      text-align: left;
    }
    
    .markdown-content th {
      background-color: #f9fafb;
      font-weight: 600;
    }
    
    .markdown-content a {
      color: #3b82f6;
      text-decoration: underline;
    }
    
    .markdown-content a:hover {
      color: #2563eb;
    }
    
    .markdown-content strong {
      font-weight: 600;
    }
    
    .markdown-content em {
      font-style: italic;
    }
    
    .markdown-content hr {
      border: none;
      border-top: 1px solid #e5e7eb;
      margin: 2em 0;
    }
    
    .markdown-content img {
      max-width: 100%;
      height: auto;
      border-radius: 0.5em;
      margin: 1em 0;
    }
  </style>
</body>
</html>